<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Docker常用命令1.帮助命令1234567docker version #显示docker的版本信息。docker info #显示docker的系统信息，包括镜像和容器的数量docker 命令 --help #帮助命令docker stats [容器id]  #查看cpu的状态docker volume 查看卷#帮助文档的地址：https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;r">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Docker常用命令1.帮助命令1234567docker version #显示docker的版本信息。docker info #显示docker的系统信息，包括镜像和容器的数量docker 命令 --help #帮助命令docker stats [容器id]  #查看cpu的状态docker volume 查看卷#帮助文档的地址：https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;r">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619336025701.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619406917525.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619415088846.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619415896288.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619416153743.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619416414563.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619416743561.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619421348498.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619421521359.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619486136409.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619487151700.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619484953538.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619490308728.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619491486394.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619493725549.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619493751677.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619493826259.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619505348228.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619506712283.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619506782187.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619572285290.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619573186199.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619578058546.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619578106449.png">
<meta property="og:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619578557479.png">
<meta property="article:published_time" content="2021-07-24T08:29:49.325Z">
<meta property="article:modified_time" content="2021-04-28T03:39:10.125Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619336025701.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Docker常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2021-07-24T08:29:49.325Z" itemprop="datePublished">2021-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><h2 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1.帮助命令"></a>1.帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker version #显示docker的版本信息。</span><br><span class="line">docker info #显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令 --help #帮助命令</span><br><span class="line">docker stats [容器id]  #查看cpu的状态</span><br><span class="line">docker volume 查看卷</span><br><span class="line"><span class="meta">#</span><span class="bash">帮助文档的地址：https://docs.docker.com/engine/reference/commandline/build/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2.镜像命令"></a>2.镜像命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker images #查看所有本地主机上的镜像 可以使用docker image ls代替</span><br><span class="line">docker search 搜索镜像</span><br><span class="line">docker pull 下载镜像 # 下载镜像 docker pull 镜像名[:tag]</span><br><span class="line">	</span><br><span class="line">docker rmi 删除镜像 </span><br><span class="line">	docker rmi -f 镜像id #删除指定的镜像</span><br><span class="line">	docker rmi -f 镜像id 镜像id 镜像id 镜像id#删除指定的镜像</span><br><span class="line">	docker rmi -f $(docker images -aq) #删除全部的镜像</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3.容器命令"></a>3.容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像id 新建容器并启动</span><br><span class="line">    docker run [可选参数] image | docker container run [可选参数] image</span><br><span class="line">    #参书说明</span><br><span class="line">    --name=&quot;Name&quot; 容器名字 tomcat01 tomcat02 用来区分容器</span><br><span class="line">    -d 后台方式运行</span><br><span class="line">    -it 使用交互方式运行，进入容器查看内容</span><br><span class="line">    -p 指定容器的端口 -p 8080(宿主机):8080(容器)</span><br><span class="line">    -p ip:主机端口:容器端口</span><br><span class="line">    -p 主机端口:容器端口(常用)</span><br><span class="line">    -p 容器端口</span><br><span class="line">    容器端口</span><br><span class="line">    -P(大写) 随机指定端口</span><br><span class="line"></span><br><span class="line">-it交互方式启动容器之后的退出容器命令</span><br><span class="line">    exit #容器直接退出</span><br><span class="line">    ctrl +P +Q #容器不停止退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker ps 列出所有运行的容器 docker container list</span><br><span class="line">    #docker ps命令 #列出当前正在运行的容器</span><br><span class="line">    -a, --all Show all containers (default shows just running)</span><br><span class="line">    -n, --last int Show n last created containers (includes all states)</span><br><span class="line">    (default -1)</span><br><span class="line">    -q, --quiet Only display numeric IDs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker rm 容器id 删除指定容器</span><br><span class="line">    docker rm 容器id #删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -rf</span><br><span class="line">    docker rm -f $(docker ps -aq) #删除指定的容器</span><br><span class="line">    docker ps -a -q|xargs docker rm #删除所有的容器</span><br><span class="line"></span><br><span class="line">启动和停止容器的操作</span><br><span class="line">    docker start 容器id #启动容器</span><br><span class="line">    docker restart容器id #重启容器</span><br><span class="line">    docker stop 容器id #停止当前正在运行的容器</span><br><span class="line">    docker kill 容器id #强制停止当前容器</span><br></pre></td></tr></table></figure>

<h2 id="4-常用其他命令"><a href="#4-常用其他命令" class="headerlink" title="4.常用其他命令"></a>4.常用其他命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">后台启动命令</span><br><span class="line">    # 命令 docker run -d 镜像名</span><br><span class="line">    ➜ ~ docker run -d centos</span><br><span class="line">    a8f922c255859622ac45ce3a535b7a0e8253329be4756ed6e32265d2dd2fac6c</span><br><span class="line">    ➜ ~ docker ps</span><br><span class="line">    CONTAINER ID IMAGE COMMAND CREATED</span><br><span class="line">    STATUS PORTS NAMES</span><br><span class="line">    # 问题docker ps. 发现centos 停止了</span><br><span class="line">    # 常见的坑，docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止</span><br><span class="line">    # nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span><br><span class="line">查看日志</span><br><span class="line">	docker logs --help</span><br><span class="line">    Options:</span><br><span class="line">    --details Show extra details provided to logs</span><br><span class="line">    * -f, --follow Follow log output</span><br><span class="line">    --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or</span><br><span class="line">    relative (e.g. 42m for 42 minutes)</span><br><span class="line">    * --tail string Number of lines to show from the end of the logs</span><br><span class="line">    (default &quot;all&quot;)</span><br><span class="line">    * -t, --timestamps Show timestamps</span><br><span class="line">    --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37)</span><br><span class="line">    or relative (e.g. 42m for 42 minutes)</span><br><span class="line">    ➜ ~ docker run -d centos /bin/sh -c &quot;while true;do echo 6666;sleep 1;done&quot; #模</span><br><span class="line">    拟日志</span><br><span class="line">    #显示日志</span><br><span class="line">    -tf #显示日志信息（一直更新）</span><br><span class="line">    --tail number #需要显示日志条数</span><br><span class="line">    docker logs -t --tail n 容器id #查看n行日志</span><br><span class="line">    docker logs -ft 容器id #跟着日志</span><br><span class="line">    </span><br><span class="line">查看容器中进程信息 ps</span><br><span class="line">    docker top 容器id	</span><br><span class="line">    </span><br><span class="line">查看容器的元数据</span><br><span class="line">    # 命令</span><br><span class="line">    docker inspect 容器id</span><br><span class="line">    #测试</span><br><span class="line">    ➜ ~ docker inspect 55321bcae33d</span><br><span class="line">    [</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;Id&quot;:</span><br><span class="line">    &quot;55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066&quot;,</span><br><span class="line">    &quot;Created&quot;: &quot;2020-05-15T05:22:05.515909071Z&quot;,</span><br><span class="line">    &quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">进入当前正在运行的容器</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span></span><br><span class="line">    # 方式一：命令</span><br><span class="line">    docker exec -it 容器id bashshell</span><br><span class="line">    # 方式二</span><br><span class="line">    docker attach 容器id</span><br><span class="line">    #测试</span><br><span class="line">    docker attach 55321bcae33d</span><br><span class="line">    正在执行当前的代码...</span><br><span class="line">    区别</span><br><span class="line">    #docker exec #进入当前容器后开启一个新的终端，可以在里面操作。（常用）</span><br><span class="line">    #docker attach # 进入容器正在执行的终端</span><br><span class="line"> </span><br><span class="line">从容器内拷贝文件到主机上</span><br><span class="line">    docker cp 容器id:容器内路径 主机目的路径</span><br><span class="line">    #进入docker容器内部</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Docker的所有命令</p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619336025701.png" alt="1619336025701"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">attach   Attach local standard input, output, and error streams to a</span><br><span class="line">running container</span><br><span class="line"><span class="meta">#</span><span class="bash">当前shell下 attach连接指定运行的镜像</span></span><br><span class="line">build   Build an image from a Dockerfile # 通过Dockerfile定制镜像</span><br><span class="line">commit  Create a new image from a container&#x27;s changes #提交当前容器为新的镜像</span><br><span class="line">cp      Copy files/folders between a container and the local filesystem #</span><br><span class="line">拷贝文件</span><br><span class="line">create  Create a new container #创建一个新的容器</span><br><span class="line">diff    Inspect changes to files or directories on a container&#x27;s</span><br><span class="line">filesystem #查看docker容器的变化</span><br><span class="line">events  Get real time events from the server # 从服务获取容器实时时间</span><br><span class="line">exec    Run a command in a running container # 在运行中的容器上运行命令</span><br><span class="line">export  Export a container&#x27;s filesystem as a tar archive #导出容器文件系统作</span><br><span class="line">为一个tar归档文件[对应import]</span><br><span class="line">history  Show the history of an image # 展示一个镜像形成历史</span><br><span class="line">images   List images #列出系统当前的镜像</span><br><span class="line">import   Import the contents from a tarball to create a filesystem image #</span><br><span class="line">从tar包中导入内容创建一个文件系统镜像</span><br><span class="line">info     Display system-wide information # 显示全系统信息</span><br><span class="line">inspect  Return low-level information on Docker objects #查看容器详细信息</span><br><span class="line">kill     Kill one or more running containers # kill指定docker容器</span><br><span class="line">load     Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载</span><br><span class="line">一个镜像[对应save]</span><br><span class="line">login    Log in to a Docker registry #</span><br><span class="line">logout   Log out from a Docker registry</span><br><span class="line">logs     Fetch the logs of a container</span><br><span class="line">pause    Pause all processes within one or more containers</span><br><span class="line">port     List port mappings or a specific mapping for the container</span><br><span class="line">ps       List containers</span><br><span class="line">pull     Pull an image or a repository from a registry</span><br><span class="line">push     Push an image or a repository to a registry</span><br><span class="line">rename   Rename a container</span><br><span class="line">restart  Restart one or more containers</span><br><span class="line">rm       Remove one or more containers</span><br><span class="line">rmi      Remove one or more images</span><br><span class="line">run		 Run a command in a new container</span><br><span class="line">save	 Save one or more images to a tar archive (streamed to STDOUT by</span><br><span class="line">default)</span><br><span class="line">search 	 Search the Docker Hub for images</span><br><span class="line">start	 Start one or more stopped containers</span><br><span class="line">stats	 Display a live stream of container(s) resource usage statistics</span><br><span class="line">stop	 Stop one or more running containers</span><br><span class="line">tag		 Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">top 	 Display the running processes of a container</span><br><span class="line">unpause	 Unpause all processes within one or more containers</span><br><span class="line">update	 Update configuration of one or more containers</span><br><span class="line">version Show the Docker version information</span><br><span class="line">wait	 Block until one or more containers stop, then print their exit</span><br><span class="line">codes</span><br></pre></td></tr></table></figure>





<h2 id="进入Nginx容器查看修改其配置文件"><a href="#进入Nginx容器查看修改其配置文件" class="headerlink" title="进入Nginx容器查看修改其配置文件"></a>进入Nginx容器查看修改其配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动nginx容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1. 搜索镜像 search 建议大家去docker搜索，可以看到帮助文档</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2. 拉取镜像 pull</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3. 运行测试</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name 给容器命名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 宿主机端口：容器内部端口</span></span><br><span class="line">[root@VM-0-12-centos ~]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">列出运行的容器</span></span><br><span class="line">[root@VM-0-12-centos ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                                   NAMES</span><br><span class="line">1aaed8873d43   nginx     &quot;/docker-entrypoint.…&quot;   17 minutes ago   Up 17 minutes   0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp   nginx01</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">进入nginx容器</span></span><br><span class="line">[root@VM-0-12-centos ~]# docker exec -it nginx01 /bin/bash</span><br><span class="line"></span><br><span class="line">root@1aaed8873d43:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line"></span><br><span class="line">root@1aaed8873d43:/# cd /etc/nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置文件nginx.conf</span></span><br><span class="line">root@1aaed8873d43:/etc/nginx# ls</span><br><span class="line">conf.d	fastcgi_params	koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params	uwsgi_params  win-utf</span><br><span class="line">root@1aaed8873d43:/etc/nginx#  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Docker可视化"><a href="#Docker可视化" class="headerlink" title="Docker可视化"></a>Docker可视化</h1><h2 id="什么是portainer？"><a href="#什么是portainer？" class="headerlink" title="什么是portainer？"></a>什么是portainer？</h2><p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行如下命令即可 打开可视化服务</span></span><br><span class="line">docker run -d -p 8080:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>





<h1 id="联合文件系统UnionFS-分层下载"><a href="#联合文件系统UnionFS-分层下载" class="headerlink" title="联合文件系统UnionFS 分层下载"></a>联合文件系统UnionFS 分层下载</h1><p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619406917525.png" alt="1619406917525"></p>
<h1 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和git原理类似</span></span><br><span class="line">docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、启动一个默认的tomca</span></span><br><span class="line">docker run -it -p 8081:8080 tomcat</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！</span></span><br><span class="line">docker exec -it 6b788389ed5a /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、拷贝文件进去</span></span><br><span class="line">cp -r webapps.dist/* webapps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、将操作过的容器通过commit提交为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像。</span></span><br><span class="line">docker commit -a=&quot;zhengbin&quot; -m=&quot;add webapps app&quot; 6b788389ed5a tomcat02:1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷："><a href="#什么是容器数据卷：" class="headerlink" title="什么是容器数据卷："></a>什么是容器数据卷：</h2><p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619415088846.png" alt="1619415088846"></p>
<p>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的</p>
<h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><p>方式一：直接使用命令来挂载数据卷   -v</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line">docker run -it -v /home/ceshi:/home centos /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id  #查看容器详细信息，查看挂载情况</span><br></pre></td></tr></table></figure>

<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619415896288.png" alt="1619415896288"></p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619416153743.png" alt="1619416153743"></p>
<p>测试文件的同步，数据卷技术</p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619416414563.png" alt="1619416414563"></p>
<p>再来测试！<br>1、停止容器<br>2、宿主机修改文件<br>3、启动容器<br>4、容器内的数据依旧是同步的</p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619416743561.png" alt="1619416743561"></p>
<p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p>
<h2 id="实战：MySQL数据同步"><a href="#实战：MySQL数据同步" class="headerlink" title="实战：MySQL数据同步"></a>实战：MySQL数据同步</h2><p>将MySQL中的数据挂载出来到本地linux 服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取mysql镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行容器,需要做数据挂载 <span class="comment">#安装启动mysql，需要配置密码的，这是要注意点！</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参考官网hub</span></span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d</span><br><span class="line">mysql:tag</span><br><span class="line"><span class="meta">#</span><span class="bash">启动我们得</span></span><br><span class="line">-d 后台运行</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 卷挂载</span><br><span class="line">-e 环境配置</span><br><span class="line">-- name 容器名字</span><br><span class="line">docker run -d -p 3300:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动成功之后，我们在本地使用sqlyog来测试一下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sqlyog-连接到服务器的3300--和容器内的3306映射</span></span><br><span class="line"><span class="meta">#</span><span class="bash">假设我们将容器删除 ：</span></span><br><span class="line">发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能。</span><br><span class="line">4.具名和匿名挂载</span><br><span class="line">所有的docker容器内的卷，没有指定目录的情况下都是在 /var/lib/docker/volumes/xxxx/_data</span><br><span class="line">下</span><br><span class="line">如果指定了目录，docker volume ls 是查看不到的。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载</span></span><br><span class="line">-v 容器内路径!</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有的volume的情况</span></span><br><span class="line">➜ ~ docker volume ls</span><br><span class="line">DRIVER VOLUME NAME</span><br><span class="line">local</span><br><span class="line">33ae588fae6d34f511a769948f0d3d123c9d45c442ac7728cb85599c2657e50d</span><br><span class="line">local</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路劲！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载</span></span><br><span class="line">➜ ~ docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line">➜ ~ docker volume ls</span><br><span class="line">DRIVER VOLUME NAME</span><br><span class="line">local juming-nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载</span></span><br><span class="line">-v 卷名：容器内路径 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下这个卷</span></span><br></pre></td></tr></table></figure>



<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619421348498.png" alt="1619421348498"></p>
<p>所有的docker容器内的卷，没有指定目录的情况下都是在 /var/lib/docker/volumes/xxxx/_data<br>下<br>如果指定了目录，docker volume ls 是查看不到的。</p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619421521359.png" alt="1619421521359"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 三种挂载： 匿名挂载、具名挂载、指定路径挂载</span></span><br><span class="line">-v 容器内路径 #匿名挂载</span><br><span class="line">-v 卷名：容器内路径 #具名挂载</span><br><span class="line">-v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的</span><br></pre></td></tr></table></figure>

<p>拓展：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 -v 容器内路径： ro rw 改变读写权限</span></span><br><span class="line">ro #readonly 只读</span><br><span class="line">rw #readwrite 可读可写</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span></span><br></pre></td></tr></table></figure>



<h2 id="初识Dockerfile"><a href="#初识Dockerfile" class="headerlink" title="初识Dockerfile"></a>初识Dockerfile</h2><p>方式二： 通过DockerFile生成一个镜像，在创建镜像的时候把数据卷挂载出来</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个dockerfile文件，名字可以随便 建议Dockerfile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件中的内容 指令(大写) 参数</span></span><br><span class="line">FROM centos</span><br><span class="line"><span class="meta"> #</span><span class="bash">通过生成一个镜像，在创建镜像的时候把数据卷挂载出来</span></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">这里的每个命令，就是镜像的一层！</span></span><br></pre></td></tr></table></figure>

<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619486136409.png" alt="1619486136409"></p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619487151700.png" alt="1619487151700"></p>
<p>多个mysql同步数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">--volumes-from 同步数据</span></span><br><span class="line"></span><br><span class="line">docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v</span><br><span class="line">/home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01</span><br><span class="line">mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name</span><br><span class="line">mysql02 --volumes-from mysql01 mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时候，可以实现两个容器数据同步！</span></span><br></pre></td></tr></table></figure>

<p>结论：<br>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。<br>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！</p>
<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p> Dockerfile 就是用来构建docker镜像的构建文件！命令脚本！先体验一下！<br>通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个dockerfile文件，名字可以随便 建议Dockerfile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件中的内容 指令(大写) 参数</span></span><br><span class="line">FROM centos</span><br><span class="line"><span class="meta"> #</span><span class="bash">通过生成一个镜像，在创建镜像的时候把数据卷挂载出来</span></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">这里的每个命令，就是镜像的一层！</span></span><br></pre></td></tr></table></figure>

<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619484953538.png" alt="1619484953538"></p>
<h2 id="DockerFile介绍"><a href="#DockerFile介绍" class="headerlink" title="DockerFile介绍"></a>DockerFile介绍</h2><p>dockerfile 是用来构建docker镜像的文件！命令参数脚本！</p>
<p>构建步骤：<br>1、 编写一个dockerfile文件<br>2、 docker build 构建称为一个镜像<br>3、 docker run运行镜像<br>4、 docker push发布镜像（DockerHub 、阿里云仓库)<br>但是很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p>
<p>官方既然可以制作镜像，那我们也可以！</p>
<h2 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h2><p>基础知识：<br>1、每个保留关键字(指令）都是必须是大写字母<br>2、执行从上到下顺序<br>3、#表示注释<br>4、每一个指令都会创建提交一个新的镜像层，并提交！</p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619490308728.png" alt="1619490308728"></p>
<p>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简<br>单！<br>Docker镜像逐渐成企业交付的标准，必须要掌握！<br>DockerFile：构建文件，定义了一切的步骤，源代码<br>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。<br>Docker容器：容器就是镜像运行起来提供服务。</p>
<h2 id="DockerFile的指令"><a href="#DockerFile的指令" class="headerlink" title="DockerFile的指令"></a>DockerFile的指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> DockerFile常用指令</span></span><br><span class="line">FROM        # 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER  # 镜像是谁写的， 姓名+邮箱</span><br><span class="line">RUN     	# 镜像构建的时候需要运行的命令</span><br><span class="line">ADD 		# 步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录</span><br><span class="line">WORKDIR 	# 镜像的工作目录</span><br><span class="line">VOLUME 		# 挂载的目录</span><br><span class="line">EXPOSE		 # 保留端口配置</span><br><span class="line">CMD 		# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span><br><span class="line">ENTRYPOINT	 # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line">ONBUILD 	 # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指</span><br><span class="line">令。</span><br><span class="line">COPY		 # 类似ADD，将我们文件拷贝到镜像中</span><br><span class="line">ENV 		# 构建的时候设置环境变量！</span><br></pre></td></tr></table></figure>

<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619491486394.png" alt="1619491486394"></p>
<h2 id="实战：创建一个自己的centos"><a href="#实战：创建一个自己的centos" class="headerlink" title="实战：创建一个自己的centos"></a>实战：创建一个自己的centos</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.编写Dockerfile文件</span></span><br><span class="line">vim mydockerfile-centos</span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER zhengbin&lt;1693303546@qq.com&gt;</span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;-----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、通过这个文件构建镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令 docker build -f 文件路径 -t 镜像名:[tag] .</span></span><br><span class="line">docker build -f mydockerfile-centos -t mycentos:0.1 .</span><br><span class="line"><span class="meta">#</span><span class="bash">3.测试运行</span></span><br></pre></td></tr></table></figure>

<p>对比：之前的原生centos</p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619493725549.png" alt="1619493725549"></p>
<p>增加之后的centos镜像</p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619493751677.png" alt="1619493751677"></p>
<p>我们可以列出本地镜像的变更历史</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history 镜像id</span><br></pre></td></tr></table></figure>

<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619493826259.png" alt="1619493826259"></p>
<h2 id="CMD和ENTRYPOINT的区别"><a href="#CMD和ENTRYPOINT的区别" class="headerlink" title="CMD和ENTRYPOINT的区别"></a>CMD和ENTRYPOINT的区别</h2><p>覆盖和追加的区别</p>
<p>cmd会被覆盖，entrypoint会进行追加</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替</span><br><span class="line">代。</span><br><span class="line">ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br></pre></td></tr></table></figure>





<h2 id="实战：创建Tomcat镜像"><a href="#实战：创建Tomcat镜像" class="headerlink" title="实战：创建Tomcat镜像"></a>实战：创建Tomcat镜像</h2><p> 1、准备镜像文件<br>准备tomcat 和 jdk到当前目录，编写好README </p>
<p>2、编写dokerfile</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM centos #</span><br><span class="line">MAINTAINER cheng&lt;1204598429@qq.com&gt;</span><br><span class="line">COPY README /usr/local/README #复制文件</span><br><span class="line">ADD jdk-8u231-linux-x64.tar.gz /usr/local/ #复制解压</span><br><span class="line">ADD apache-tomcat-9.0.35.tar.gz /usr/local/ #复制解压</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">ENV MYPATH /usr/local #设置环境变量</span><br><span class="line">WORKDIR $MYPATH #设置工作目录</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_231 #设置环境变量</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.35 #设置环境变量</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib #设置环境变量 分隔符是：</span><br><span class="line">EXPOSE 8080 #设置暴露的端口</span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/local/apachetomcat-9.0.35/logs/catalina.out # 设置默认命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 3、构建镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 因为dockerfile命名使用默认命名 因此不用使用-f 指定文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker build -t mytomcat:0.1 .</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.运行docker镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 8080:8080 --name tomcat01 -v</span></span><br><span class="line">/home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test -</span><br><span class="line">v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs</span><br><span class="line">mytomcat:0.1</span><br></pre></td></tr></table></figure>

<p>5、访问测试<br>6、发布项目(由于做了卷挂载，我们直接在本地编写项目就可以发布了！)<br>发现：项目部署成功，可以直接访问！<br>我们以后开发的步骤：需要掌握dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！</p>
<h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><p>1、地址 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a><br>2、确定这个账号可以登录<br>3、登录 </p>
<p>docker login -u 登录账号</p>
<p>输入密码进行登录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker login --<span class="built_in">help</span></span></span><br><span class="line">Usage: docker login [OPTIONS] [SERVER]</span><br><span class="line">Log in to a Docker registry.</span><br><span class="line">If no server is specified, the default is defined by the daemon.</span><br><span class="line">Options:</span><br><span class="line">-p, --password string Password</span><br><span class="line">--password-stdin Take the password from stdin</span><br><span class="line">-u, --username string Username</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.提交push镜像</p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619505348228.png" alt="1619505348228"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 会发现push不上去，因为如果没有前缀的话默认是push到 官方的library</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决方法</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker build -t chengcoder/mytomcat:0.1 .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二种 使用docker tag <span class="comment">#然后再次push</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker tag 容器id chengcoder/mytomcat:1.0 <span class="comment">#然后再次push</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>发布镜像到阿里云服务上</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">看官网 很详细https://cr.console.aliyun.com/repository/</span><br><span class="line">​```shell</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker login --username=zchengx registry.cn-shenzhen.aliyuncs.com</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像</span></span><br><span class="line">版本号]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改id 和 版本</span></span><br><span class="line">sudo docker tag a5ef1f32aaae registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:1.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker push registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]</span></span><br></pre></td></tr></table></figure>



<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619506712283.png" alt="1619506712283"></p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619506782187.png" alt="1619506782187"></p>
<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><p>1、我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要按照了docker，<br>就会有一个docker0桥接模式，使用的技术是veth-pair技术！</p>
<p>tomcat01容器 ping tomcat02容器可以ping通 ，是通过veth pair技术</p>
<h2 id="网络模型绘制"><a href="#网络模型绘制" class="headerlink" title="网络模型绘制"></a>网络模型绘制</h2><p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619572285290.png" alt="1619572285290"></p>
<p><strong>结论</strong>：tomcat01和tomcat02公用一个路由器，docker0。<br>所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用<br>ip。</p>
<p><strong>小结</strong> ：Docker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥  docker0</p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619573186199.png" alt="1619573186199"></p>
<p>Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）</p>
<p>只要容器删除，对应的网桥一对就没了！</p>
<h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><h2 id="–link（麻烦、过时）"><a href="#–link（麻烦、过时）" class="headerlink" title="–link（麻烦、过时）"></a>–link（麻烦、过时）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it tomcat02 ping tomca01 <span class="comment"># ping不通</span></span></span><br><span class="line">ping: tomca01: Name or service not known</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行一个tomcat03 --link tomcat02</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -P --name tomcat03 --link tomcat02 tomcat</span></span><br><span class="line">5f9331566980a9e92bc54681caaac14e9fc993f14ad13d98534026c08c0a9aef</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用tomcat03 ping tomcat02 可以ping通</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it tomcat03 ping tomcat02</span></span><br><span class="line">PING tomcat02 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.080 ms</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用tomcat02 ping tomcat03 ping不通</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义网络-推荐使用"><a href="#自定义网络-推荐使用" class="headerlink" title="自定义网络(推荐使用)"></a>自定义网络(推荐使用)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker network</span><br><span class="line">connect -- Connect a container to a network</span><br><span class="line">create -- Creates a new network with a name specified by the</span><br><span class="line">disconnect -- Disconnects a container from a network</span><br><span class="line">inspect -- Displays detailed information on a network</span><br><span class="line">ls -- Lists all the networks created by the user</span><br><span class="line">prune -- Remove all unused networks</span><br><span class="line">rm -- Deletes one or more networks</span><br></pre></td></tr></table></figure>

<p>网络模式<br>bridge ：桥接 docker（默认，自己创建也是用bridge模式）<br>none ：不配置网络，一般不用<br>host ：和所主机共享网络<br>container ：容器网络连通（用得少！局限很大）<br>测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们直接启动的命令 --net bridge,而这个就是我们得docker0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bridge就是docker0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span></span><br><span class="line">等价于 =&gt; docker run -d -P --name tomcat01 --net bridge tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker0，特点：默认，域名不能访问。 --link可以打通连接，但是很麻烦！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可以 自定义一个网络</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker network create --driver bridge --subnet 192.168.0.0/16 --gateway</span></span><br><span class="line">192.168.0.1 mynet</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619578058546.png" alt="1619578058546"></p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619578106449.png" alt="1619578106449"></p>
<p>打通容器和网络</p>
<p><img src="Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/1619578557479.png" alt="1619578557479"></p>
<h2 id="实战：部署Redis集群"><a href="#实战：部署Redis集群" class="headerlink" title="实战：部署Redis集群"></a>实战：部署Redis集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建网卡</span></span><br><span class="line">docker network create redis --subnet 172.38.0.0/16</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过脚本创建六个redis配置</span></span><br><span class="line">for port in $(seq 1 6);\</span><br><span class="line">do \</span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf</span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;&gt; /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1$&#123;port&#125;</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过脚本运行六个redis</span></span><br><span class="line">for port in $(seq 1 6);\</span><br><span class="line">docker run -p 637$&#123;port&#125;:6379 -p 1667$&#123;port&#125;:16379 --name redis-$&#123;port&#125; -v /mydata/redis/node-$&#123;port&#125;/data:/data -v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"> docker run -p 6371:6379 -p 16371:16379 --name redis-1 \</span><br><span class="line">    -v /mydata/redis/node-1/data:/data \</span><br><span class="line">    -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">    -d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker exec -it redis-1 /bin/sh #redis默认没有bash</span><br><span class="line">redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379</span><br><span class="line">172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot微服务打包Docker镜像"><a href="#SpringBoot微服务打包Docker镜像" class="headerlink" title="SpringBoot微服务打包Docker镜像"></a>SpringBoot微服务打包Docker镜像</h2><p>1、构建SpringBoot项目<br>2、打包运行</p>
<p> 3、编写dockerfile</p>
<p>4、构建镜像</p>
<p> 5、发布运行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="ckrhio1ip0001jwtl7zoz2pie" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/07/22/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/24/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/07/22/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>